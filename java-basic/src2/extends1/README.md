# 상속

## 1. 정의  
<span style="color:skyblue;">**기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용**</span>하게 해준다. 중복을 줄일 수 있음.

## 2. 상속 관계  
- 상속을 사용하려면 <span style="color:skyblue;">**`extends`**</span> 키워드를 사용한다.  
- 자식 클래스는 부모 클래스를 알지만, 부모 클래스는 자식 클래스에 접근할 수 없다.  
- 자바는 다중 상속을 지원하지 않는다. `extends`의 대상이 될 부모 클래스는 하나만 선택할 수 있음.  
  - 예를 들어, `비행기`와 `자동차`를 상속받아 `하늘을 나는 자동차`를 만든다고 할 때,  
    `move()` 메서드를 어느 부모의 것을 사용할지 모호해짐.  
  - 클래스 계층 구조가 복잡해지고 유지보수가 어려워짐.

## 3. 상속과 메모리 구조 <span style="color:red;">★★★</span>  
- <span style="color:skyblue;">**상속 관계의 객체를 생성하면 부모와 자식 클래스의 인스턴스가 모두 생성됨.**</span>  
- `electricCar.charge()`를 호출할 때, 참조 변수를 기준으로 메서드를 찾음.  
- 호출하는 변수의 타입(클래스)을 기준으로 메서드 선택.  
- `move()`처럼 현재 클래스에서 기능을 찾지 못하면 상위 부모 타입에서 기능을 찾아 실행.  
- 최상위 부모 클래스까지 거슬러 올라가도 기능이 없으면 컴파일 오류 발생.

## 4. 상속과 기능 추가  
부모 클래스를 상속받아 새로운 기능을 추가할 수 있음.

## 5. 상속과 메서드 오버라이딩  
- <span style="color:skyblue;">**메서드 오버라이딩: 부모에게서 상속받은 기능을 자식 클래스가 재정의**</span>하는 것.  
- 메서드 재정의라고도 함.  
- 오버라이딩 조건  
  1. 메서드 이름이 같아야 함.  
  2. 파라미터 타입, 순서, 개수가 같아야 함.  
  3. 반환 타입이 같아야 함.  
  4. 접근 제어자가 부모 클래스의 메서드보다 더 제한적이면 안 됨.  
  5. 다음 경우 오버라이딩 불가:  
     - `static`, `final`, `private` 키워드가 붙은 메서드  
     - 생성자  
- `@Override` 어노테이션을 사용하여 정확히 오버라이드되었는지 확인 가능 (권장).  
- 오버로딩과 구분  
  - 오버로딩: 메서드 이름은 같지만, 매개변수가 다름(타입, 개수, 순서 변경).  

## 6. 상속과 접근 제어  
- <span style="color:skyblue;">**`protected`**</span>: 같은 패키지 내에서 호출 가능. 패키지가 다르더라도 상속 관계에서는 호출 허용.  
- 부모 클래스의 메서드는 결국 외부에서 호출하는 것과 같음.  
- 즉, 자식 클래스에서도 부모 클래스의 기능을 호출할 때 접근 제한이 적용됨.

## 7. super - 부모 참조
- this는 자기 자신을 참조하며 생략 가능
- super는 부모 클래스에 대한 참조
- 상속 관계의 생성자 호출은 결과적으로 <span style="color:skyblue;">**부모에서 자식 순서로 실행**</span>됨. 자식 생성자가 먼저 호출되는 것은 맞으나, 상속 관계에서 자식 클래스의 생성자 첫줄에 반드시 super를 호출해야 하기 때문임. 기본 생성자의 경우 생략 가능
- 예외로 생성자 첫줄에 this()를 사용할 수 있지만, <span style="color:skyblue;">**super()는 자식의 생성자 안에서 언젠가는 반드시 호출**</span>해야 함.
